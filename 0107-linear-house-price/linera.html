<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis"></script>
    <title>Document</title>
</head>

<body>
    <h1>Tensor Practice</h1>
    <script>
        // scv file data visualization - scatter plot
        async function plot(pointsArray, featureName) {
            surface = {name: `${featureName} vs Price`}
            data = {values: [pointsArray], series: ['original']}
            options = {xLabel: featureName, yLabel: "Price"}
            tfvis.render.scatterplot(surface, data, options);
        }
        
        async function run() {
            // csv data loading
            const houseSales = tf.data.csv("./kc_house_data.csv");

            const points = houseSales.map(record => ({
                x: record.sqft_living,
                y: record.price
            }));
            const dataPoints = await points.toArray();

            // DATA shuffle before train/test split
            tf.util.shuffle(dataPoints);

            // visualize data
            plot(dataPoints, "Square Feet");

            // feature extraction and tensor 변환 
            const featureValues = dataPoints.map(p => p.x);
            const featureTensor = tf.tensor2d(featureValues, [featureValues.length, 1]);
            const labelValues = dataPoints.map(p => p.y);
            const labelTensor = tf.tensor2d(labelValues, [labelValues.length, 1]);

            // featureTensor.print();
            // labelTensor.print();

            // min-max scaling 함수
            function normalize(tensor) {
                const min = tensor.min();
                const max = tensor.max();
                const normedTensor = tensor.sub(min).div(max.sub(min));
                return {
                    tensor : normedTensor,
                    min,
                    max
                }
            }
            // denormalization of min-max scaling 
            function denormalize(tensor, min, max){
                return denormedTensor = tensor.mul(max.sub(min)).add(min);
            }
            // normalized fearue & label
            const normedFeatureTensor = normalize(featureTensor);
            const normedLabelTensor = normalize(labelTensor);

            // train / test set split
            const [X_train, X_test] = tf.split(normedFeatureTensor.tensor, 2);
            const [y_train, y_test] = tf.split(normedLabelTensor.tensor, 2);
            X_train.print(true);
            
            // normedFeatureTensor.tensor.print();
            // normedLabelTensor.tensor.print();
            // denormalize(normedFeatureTensor.tensor, 
            //                 normedFeatureTensor.min, normedFeatureTensor.max).print();
            
            // Visualize normalized scatterplot   
            // scatterplot 은 [{x, y}] nested tuple 형태의 array 를 입력으로 요구           
            // const normedFeatureArr = normedFeatureTensor.tensor.arraySync();
            // const normedLabelArr = normedLabelTensor.tensor.arraySync();
            // const normedPoints = [];
            // for (let i = 0; i < normedFeatureArr.length; i++){
            //     normedPoints.push({x: normedFeatureArr[i], y: normedLabelArr[i]});
            // }
            // plot(normedPoints, "Normed Square Feet");
            
            // Linear Model 을 layers API 를 이용하여 구축
            const model = tf.sequential();
            model.add(tf.layers.dense({
                inputShape: [1],
                units: 1,
                activation: 'linear'
            }));
            //model compile
            const optimizer = tf.train.sgd(0.1)
            model.compile({
                loss: 'meanSquaredError',
                optimizer: optimizer
            })
            model.summary();
            //summary 시각화
            tfvis.show.modelSummary({name: "model summary"}, model);
            //tfvis showLayr 로 layer 정보 시각화를 위해 getLayer
            //1st argument 가 optional 이므로 undefined 로 한다.
            const layer = model.getLayer(undefined, 0);
            tfvis.show.layer({name: "Layer 1"}, layer);

            //train model
            //onEpochEnd: (epoch, log) => console.log(`Epoch ${epoch}: loss= ${log.loss}`)
            // function onBatchEnd(batch, logs) {
            //     console.log('Accuracy', logs.acc);
            // }

            const {onBatchEnd, onEpochEnd} = tfvis.show.fitCallbacks(
                        {name: "Training Performance"},
                         ['loss', 'acc']
                         )

            const result = await model.fit(X_train, y_train, {
                epochs: 30,
                batchSize: 32,
                validationSplit: 0.2,
                callbacks: {
                    onBatchEnd, onEpochEnd
                }
            });
            // train, validation loss 출력
            const trainLoss = result.history.loss.pop();
            const validationLoss = result.history.val_loss.pop();
            console.log(`Train Loss = ${trainLoss} \nValidation Loss = ${validationLoss}`);
            // test set validation
            const lossTensor = await model.evaluate(X_test, y_test).dataSync();
            console.log(`Test set loss : ${parseFloat(lossTensor).toFixed(5)}`);
        };
        run();
    </script>
</body>

</html>