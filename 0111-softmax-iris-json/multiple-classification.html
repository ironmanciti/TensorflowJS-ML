<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js"></script>
    <title>Multi-Class Classification</title>
</head>

<body>
    <h1>Multi-Class Classification</h1>
    <script>
        const EPOCHS = 50;
        let normedFearureTensor, normedLabelTensor;
        let X_train, X_test, y_train, y_test, model;
        let labelNames = ['setosa', 'versicolor', 'virginica'];

        async function run() {
            // json data loading
            //const iris = await (await fetch('./iris.json')).json();
            let iris = await fetch('./iris.json');
            iris = await iris.json();

            let points = iris.map(record => ({
                x: [record.sepal_length, record.sepal_width,
                    record.petal_length, record.petal_width],
                y: record.species,
            }))
            //shuffling data
            dataPoints = _.shuffle(points);

            plot(dataPoints);

            //category 변수 처리
            points.map(p => {
                if (p.y === 'setosa') {
                    p.y = 0;
                } else if (p.y === 'versicolor') {
                    p.y = 1;
                } else if (p.y === 'virginica') {
                    p.y = 2;
                }
            })

            // feature extraction & tensor 변환
            const featureValues = dataPoints.map(p => p.x);
            const featureTensor = tf.tensor2d(featureValues, [featureValues.length, 4])

            const labelValues = dataPoints.map(p => p.y);
            let labelTensor = tf.tensor1d(labelValues, 'int32')

            normedFearureTensor = MinMaxScaling(featureTensor);

            // One-Hot encoding of labelTensor
            labelTensor = tf.oneHot(labelTensor, 3);

            featureTensor.dispose();

            // train / test set split
            const trainLen = Math.floor(normedFearureTensor.tensor.shape[0] * 0.75);
            const testLen = normedFearureTensor.tensor.shape[0] - trainLen;
            [X_train, X_test] = tf.split(normedFearureTensor.tensor, [trainLen, testLen]);
            [y_train, y_test] = tf.split(labelTensor, [trainLen, testLen]);

            document.getElementById("train-button").removeAttribute("disabled");
        }
        // data plot
        async function plot(dataPoints) {
            const surface = {name: "Muti-Class classification"};
            const series1 = dataPoints.filter(point => point.y === 'setosa')
                            .map(point => ({
                                x: point.x[0],  //sepal_length
                                y: point.x[2]   //petal_length
                            }))
            const series2 = dataPoints.filter(point => point.y === 'versicolor')
                .map(point => ({
                    x: point.x[0],  //sepal_length
                    y: point.x[2]   //petal_length
                }))
            const series3 = dataPoints.filter(point => point.y === 'virginica')
                .map(point => ({
                    x: point.x[0],  //sepal_length
                    y: point.x[2]   //petal_length
                }))
            const data = {values: [series1, series2, series3], 
                         series: labelNames};
            const options = {xLabel: "sepal_length", yLabel: "petal_length"}
            tfvis.render.scatterplot(surface, data, options)
        }

        function toggleVisor() {
            tfvis.visor().toggle();
        }

        //data normalization - min-max scaling
        function MinMaxScaling(tensor, prevMin = null, prevMax = null) {
            const min = prevMin || tensor.min();
            const max = prevMax || tensor.max();
            const normedTensor = tensor.sub(min).div(max.sub(min));
            return {
                tensor: normedTensor,
                min,
                max
            }
        }

        async function train(){
            // Linear Model 을 layers API 를 이용하여 구축
            document.getElementById("model-status").innerHTML = "Training...."

            model = tf.sequential();
            
            model.add(tf.layers.dense({
                inputShape: [4],
                units: 100,
                activation: 'relu'
            }))
            model.add(tf.layers.dense({
                units: 50,
                activation: 'relu'
            }))
            model.add(tf.layers.dense({
                units: 3,
                activation: 'softmax'
            }))
            //model compile
            const optimizer = tf.train.adam();
            model.compile({
                loss: 'categoricalCrossentropy',
                optimizer: optimizer,
                metrics: ['accuracy']
            })
            //model.summary();
            //summary 시각화
            tfvis.show.modelSummary({name: "model summary"}, model);

            //train model
            const {onBatchEnd, onEpochEnd} = tfvis.show.fitCallbacks(
                        {name: "Training Performance"},
                         ['loss', 'acc', 'val_loss', 'val_acc']
                         )

            const result = await model.fit(X_train, y_train, {
                epochs: EPOCHS,
                batchSize: 32,
                validationSplit: 0.2,
                callbacks: {
                    onBatchEnd, onEpochEnd
                }
            });
            // train, validation loss 출력
            const trainLoss = result.history.loss.pop();
            const validationLoss = result.history.val_loss.pop();
            
            document.getElementById("test-button").removeAttribute("disabled");
            document.getElementById("save-button").removeAttribute("disabled");
            document.getElementById("predict-button").removeAttribute("disabled");

            document.getElementById("model-status").innerText
                = `Train Loss = ${parseFloat(trainLoss).toPrecision(5)} \nValidation Loss = ${validationLoss}`;
        }

        async function test(){
            // test set validation
            const lossTensor = model.evaluate(X_test, y_test);
            const loss = await lossTensor[0].dataSync()[0];
            const accuracy = await lossTensor[1].dataSync()[0];

            document.getElementById("testing-status").innerHTML 
                = `Test set loss : ${parseFloat(loss).toFixed(5)}  accuracy : ${parseFloat(accuracy).toFixed(5)}`;
            
            //per class accuracy 시각화
            const s = model.predict(X_test);
            const classAccuracy = await tfvis.metrics.perClassAccuracy(y_test.argMax(1), s.argMax(1));
            let container = {name: 'Accuracy', tab: 'Evaluation'};

            tfvis.show.perClassAccuracy(container, classAccuracy);

            //confusion maxtrix 시각화
            const confusionMatrix = await tfvis.metrics.confusionMatrix(y_test.argMax(1), s.argMax(1));
            container = {name: 'Confusion Matrix', tab: 'Evaluation'};
            tfvis.render.confusionMatrix(container, {values: confusionMatrix});

            s.dispose();
        }

        const storageID = "kc-iris-softmax";
        async function save() {
            const saveResult = await model.save(`localstorage://${storageID}`);
            document.getElementById("model-status").innerText 
                = `Model 저장 - ${saveResult.modelArtifactsInfo.dateSaved}`;
            document.getElementById("load-button").removeAttribute("disabled");
        }

        async function load() {
            const storageKey = `localstorage://${storageID}`;
            //local storage 내에 model 존재 여부 check
            const models = await tf.io.listModels(storageKey);
            const modelInfo = models[storageKey];
            if (modelInfo){
                //model load
                model = await tf.loadLayersModel(storageKey);
                //model summary 출력
                tfvis.show.modelSummary({name: "Model Summary"}, model);
            } else {
                alert("저장된 model 이 없습니다.");
            }
        }

        async function predict() {
            const inputOne = parseInt(document.getElementById('predict-input-1').value);
            const inputTwo = parseInt(document.getElementById('predict-input-2').value);
            const inputThree = parseInt(document.getElementById('predict-input-3').value);
            const inputFour = parseInt(document.getElementById('predict-input-4').value);

            if (isNaN(inputOne) || isNaN(inputTwo) || isNaN(inputThree) || isNaN(inputFour)) {
                alert("숫자를 입력하세요");
            } else {
                const features = [inputOne, inputTwo, inputThree, inputFour];
                // tensor 변환
                const tempTensor = tf.tensor2d(features, [1, 4]);
                const normedTensor = MinMaxScaling(tempTensor, normedFearureTensor.min, normedFearureTensor.max); 
                tempTensor.dispose();
                console.log(normedTensor)

                const prediction = model.predict(normedTensor.tensor);    
                const idx = prediction.argMax(1).dataSync();
                document.getElementById("predict-output").innerHTML 
                    = `Predicted Class = ${labelNames[idx]}`;
            }
        }

        run();
    </script>
    <button onclick="toggleVisor()">Toggle Visor</button><br><br>
    <div id="model-status">No trained model</div>
    <div id="testing-status"></div>
    <button id="train-button" disabled onclick="train()">Train New Model</button>
    <button id="test-button" disabled onclick="test()">Test Trained Model</button><br><br>
    <button id="save-button" disabled onclick="save()">Save Trained Model</button>
    <button id="load-button" disabled onclick="load()">Load Saved Model</button><br><br>
    <input id="predict-input-1" placeholder="sepal_length: 5.1" /><br>
    <input id="predict-input-2" placeholder="sepal_width: 3.5" /><br>
    <input id="predict-input-3" placeholder="petal_length: 1.4" /><br>
    <input id="predict-input-4" placeholder="petal_width: 0.2" /><br>
    <button id="predict-button" disabled onclick="predict()">Predict new Data</button><br>
    <div id="predict-output"></div>
</body>

</html>