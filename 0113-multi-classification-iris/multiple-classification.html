<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js"></script>
    <title>Multi-Class Classification</title>
</head>

<body>
    <h1>Multi-Class Classification</h1>
    <script>
        const EPOCHS = 100;
        let normedFeatures = [];
        let normedFearureTensors;
        let X_train, X_test, y_train, y_test, model;
        let labelNames = ['setosa', 'versicolor', 'virginica'];

        // data plot
        async function plot(dataPoints) {
            const surface = {name: "Muti-Class classification"};
            let temp = dataPoints.map(p => p.c);
            const allSeries = [... new Set(temp)]
            const series = [];
            const seriesName = [];
            // multi-class 종류별로 series 구분 표시
            for (let i = 0; i < allSeries.length; i++){
                temp = dataPoints.filter(point => point.c === allSeries[i])
                            .map(point => ({
                                x: point.x1,
                                y: point.x3
                            }));
                series.push(temp);
                seriesName.push(allSeries[i] + ' species');
            }
            const data = {values: series, series: seriesName};
            const options = {xLabel: "sepal_length", yLabel: "petal_length"}
            tfvis.render.scatterplot(surface, data, options)
        }

        function toggleVisor() {
            tfvis.visor().toggle();
        }

        //data normalization - min-max scaling
        function normalize(values, prevMin=null, prevMax=null) {
                let min, max;
                if (prevMin != null) {  //prevMin, prevMax 가 0 인 경우도 감안해야 하므로 != null 로 check
                    min = prevMin;
                } else {
                    min = Math.min(...values);
                }
                if (prevMax != null) {
                    max = prevMax;
                } else {
                    max = Math.max(...values);
                }

                const normedValues = values.map(value => (value - min) / (max - min));

                return {
                    values : normedValues,
                    min,
                    max
                }
            }

        // denormalization of min-max scaling 
        function denormalize(values, min, max){
            return denormedValues = values.map(value => value * (max - min) + min);
        }

        async function train(){
            // Linear Model 을 layers API 를 이용하여 구축
            document.getElementById("model-status").innerHTML = "Training...."

            model = tf.sequential();
            
            model.add(tf.layers.dense({
                inputShape: [4],
                units: 100,
                activation: 'relu'
            }))
            model.add(tf.layers.dense({
                units: 50,
                activation: 'relu'
            }))
            model.add(tf.layers.dense({
                units: 3,
                activation: 'softmax'
            }))
            //model compile
            const optimizer = tf.train.adam();
            model.compile({
                loss: 'categoricalCrossentropy',
                optimizer: optimizer,
                metrics: ['accuracy']
            })
            //model.summary();
            //summary 시각화
            tfvis.show.modelSummary({name: "model summary"}, model);
            //tfvis showLayr 로 layer 정보 시각화를 위해 getLayer
            //1st argument 가 optional 이므로 undefined 로 한다.
            let layer = model.getLayer(undefined, 0);
            tfvis.show.layer({name: "Layer 1"}, layer);

            //train model
            //onEpochEnd: (epoch, log) => console.log(`Epoch ${epoch}: loss= ${log.loss}`)
            // function onBatchEnd(batch, logs) {
            //     console.log('Accuracy', logs.acc);
            // }

            const {onBatchEnd, onEpochEnd} = tfvis.show.fitCallbacks(
                        {name: "Training Performance"},
                         ['loss', 'acc']
                         )

            const result = await model.fit(X_train, y_train, {
                epochs: EPOCHS,
                batchSize: 32,
                validationSplit: 0.2,
                callbacks: {
                    onBatchEnd, onEpochEnd,
                    onEpochBegin: async () => {
                        layer = model.getLayer(undefined, 0);
                        tfvis.show.layer({name: "Layer 1"}, layer);
                    }
                }
            });
            // train, validation loss 출력
            const trainLoss = result.history.loss.pop();
            const validationLoss = result.history.val_loss.pop();
            
            document.getElementById("test-button").removeAttribute("disabled");
            document.getElementById("save-button").removeAttribute("disabled");
            document.getElementById("predict-button").removeAttribute("disabled");

            document.getElementById("model-status").innerText
                = `Train Loss = ${parseFloat(trainLoss).toPrecision(5)} \nValidation Loss = ${validationLoss}`;
        }

        async function test(){
            // test set validation
            //const lossTensor = await model.evaluate(X_test, y_test).dataSync();
            const lossTensor = model.evaluate(X_test, y_test);
            const loss = (await lossTensor[0].dataSync())[0];
            const accuracy = await lossTensor[1].dataSync()[0];
            // console.log(`Test set loss : ${parseFloat(loss).toFixed(5)}`);
            // console.log(`Test set accuracy : ${parseFloat(accuracy).toFixed(5)}`);
            document.getElementById("testing-status").innerHTML 
                = `Test set loss : ${parseFloat(loss).toFixed(5)}  accuracy : ${parseFloat(accuracy).toFixed(5)}`;
            
            //per class accuracy 시각화
            const s = model.predict(X_test);
            const classAccuracy = await tfvis.metrics.perClassAccuracy(y_test.argMax(1), s.argMax(1));
            let container = {name: 'Accuracy', tab: 'Evaluation'};

            tfvis.show.perClassAccuracy(container, classAccuracy);

            //confusion maxtrix 시각화
            const confusionMatrix = await tfvis.metrics.confusionMatrix(y_test.argMax(1), s.argMax(1));
            container = {name: 'Confusion Matrix', tab: 'Evaluation'};
            tfvis.render.confusionMatrix(container, {values: confusionMatrix});

            s.dispose();
        }

        const storageID = "kc-iris-softmax";
        async function save() {
            const saveResult = await model.save(`localstorage://${storageID}`);
            document.getElementById("model-status").innerText 
                = `Model 저장 - ${saveResult.modelArtifactsInfo.dateSaved}`;
            document.getElementById("load-button").removeAttribute("disabled");
        }

        async function load() {
            const storageKey = `localstorage://${storageID}`;
            //local storage 내에 model 존재 여부 check
            const models = await tf.io.listModels(storageKey);
            const modelInfo = models[storageKey];
            if (modelInfo){
                //model load
                model = await tf.loadLayersModel(storageKey);
                //model summary 출력
                tfvis.show.modelSummary({name: "Model Summary"}, model);
            } else {
                alert("저장된 model 이 없습니다.");
            }
        }

        async function predict() {
            const inputOne = [parseInt(document.getElementById('predict-input-1').value)];
            const inputTwo = [parseInt(document.getElementById('predict-input-2').value)];
            const inputThree = [parseInt(document.getElementById('predict-input-3').value)];
            const inputFour = [parseInt(document.getElementById('predict-input-4').value)];

            if (isNaN(inputOne) || isNaN(inputTwo) || isNaN(inputThree)) {
                alert("숫자를 입력하세요");
            } else {
                const features = [inputOne, inputTwo, inputThree, inputFour];
                //normalize
                const featureValues = [];
                for (let i = 0; i < features.length; i++){
                    const temp = normalize(features[i], normedFeatures[i].min, normedFeatures[i].max);
                    featureValues.push(temp.values);
                }
                
                // tensor 변환
                const tempTensors = tf.tensor2d(featureValues, [featureValues.length, featureValues[0].length]);
                normedFearureTensors = tf.transpose(tempTensors); 
                tempTensors.dispose();

                const prediction = model.predict(normedFearureTensors);    
                const idx = prediction.argMax(1).dataSync();
                document.getElementById("predict-output").innerHTML 
                    = `Predicted Class = ${labelNames[idx]}`;

            }
        }

        async function run() {
            // json data loading
            const iris = await (await fetch('./iris.json')).json();
            let points = iris.map(record => ({
                x1: record.sepal_length,
                x2: record.sepal_width,
                x3: record.petal_length,
                x4: record.petal_width,
                c: record.species,
            }))
            //shuffling data
            points = _.shuffle(points);
            
            plot(points);

            //category 변수 처리
            points.map(p => {
                if (p.c === 'setosa'){
                    p.c = 0;
                } else if (p.c === 'versicolor'){
                    p.c = 1;
                } else if (p.c === 'virginica'){
                    p.c = 2;
                }
            })
      
            // feature extraction 
            const features = [];
            features.push(points.map(p => p.x1));
            features.push(points.map(p => p.x2));
            features.push(points.map(p => p.x3));
            features.push(points.map(p => p.x4));

            const labels = points.map(p => p.c);
            
            // Normalize
            const featureValues = [];
            for (let i = 0; i < features.length; i++){
                normedFeatures.push(normalize(features[i]));
                featureValues.push(normedFeatures[i].values);
            }

            // tensor 변환
            let tempTensors = tf.tensor2d(featureValues, [featureValues.length, featureValues[0].length]);

            normedFearureTensors = tf.transpose(tempTensors); 

            // One-Hot encoding of labelTensor
            const labelTensor = tf.oneHot(tf.tensor1d(labels, "int32"), 3);

            tempTensors.dispose();

            // train / test set split
            const trainLen = Math.floor(normedFearureTensors.shape[0] * 0.75);
            const testLen = normedFearureTensors.shape[0] - trainLen;
            [X_train, X_test] = tf.split(normedFearureTensors, [trainLen, testLen]);
            [y_train, y_test] = tf.split(labelTensor, [trainLen, testLen]);

            document.getElementById("train-button").removeAttribute("disabled");
        }

        run();
    </script>
    <button onclick="toggleVisor()">Toggle Visor</button><br><br>
    <div id="model-status">No trained model</div>
    <div id="testing-status"></div>
    <button id="train-button" disabled onclick="train()">Train New Model</button>
    <button id="test-button" disabled onclick="test()">Test Trained Model</button><br><br>
    <button id="save-button" disabled onclick="save()">Save Trained Model</button>
    <button id="load-button" disabled onclick="load()">Load Saved Model</button><br><br>
    <input id="predict-input-1" placeholder="sepal_length: 5.1" /><br>
    <input id="predict-input-2" placeholder="sepal_width: 3.5" /><br>
    <input id="predict-input-3" placeholder="petal_length: 1.4" /><br>
    <input id="predict-input-4" placeholder="petal_width: 0.2" /><br>
    <button id="predict-button" disabled onclick="predict()">Predict new Data</button><br>
    <div id="predict-output"></div>
</body>

</html>